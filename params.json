{"name":"LoCO","body":"## LoCO - Loosely Coupled Objects\r\n\r\n_LoCO_ is a set of C++ classes that make it easy to create command-line and GUI\r\napplications with any language that compiles to JavaScript.\r\nJavaScript is used to glue together binary components, optionally loaded\r\nat run-time, developed in C++.\r\nObjects are connected through signals/slots or by direct reference through\r\na QObject pointer, giving to the objects the responsibility to check the\r\ninterface semantic or the object type.\r\n\r\n##History and status\r\n\r\nThis project started several years ago when I got tired of spending time\r\nwriting C/C++ code to build MVP/MVVM/MVC application logic and binding UI\r\nevents to callbacks with MOTIF/MFC/GTK/Qt/WPF... + a few mobile frameworks.\r\nAfter some time spent experimenting with different scripting languages and their\r\nbindings to GUI frameworks I settled on Qt for desktop applications simply because \r\nit's been and still is the fastest path to building cross-platform applications\r\nscriptable in a widespread scripting language such as ECMAScript/JavaScript. \r\n\r\n###Status\r\n\r\nThe code you see here was physically extracted from a private project here on GitHub, so\r\nit is now what used to be my private development branch and it is therefore a work in progress.\r\n\r\nThe current project is a stripped down, cleaned-up, partially rewritten\r\nversion of a larger and much garbled project which also had some Lua, \r\nPython, Tcl and Scheme bindings; the only additional parts I'm planning to move into the\r\nnew project are:\r\n\r\n * OpenGL/OSG graphics view\r\n * OpenCL bindings\r\n * SQL and NoSQL database interfaces\r\n \r\nbut I might make also available other pieces as brand new projects,\r\nas I did with [QLua](/candycode/qlua) or code snippets as in the case of one\r\nof my many _[Any type](/candycode/typeless)_ implementation.\r\n\r\n##License\r\n\r\n_LoCO_ is distributes under the terms of the [New BSD License](/candycode/loco/blob/master/license/README.md)\r\n\r\n\r\n## Main features\r\n\r\nUse JavaScript to invoke methods and access properties in QObject-derived\r\nobjects.\r\n\r\nConnect:\r\n* JavaScript signals to QObject slots\r\n* QObject signals to JavaScript functions\r\n* QObject signals to QObject slots \r\n\r\nPass QObject pointers to QObject methods from JavaScript.\r\n\r\nLoad QObjects from binary plugins.\r\n\r\nDistribute applications as a standalone executable with all the resources\r\nstored in the executable itself.\r\n\r\nUse standard Web tools to develp desktop applications.\r\n\r\n### GUI\r\n\r\nThe main GUI toolkit is intended to be WebKit but in order to support\r\nnative widgets a  number of wrappers are already available for \r\naccessing system dialogs and controls such as the MacOS drawer and top\r\nlevel menu; more are being added. In the future it will be possible\r\nto specify an entire native GUI through JSON and use [Knockoutjs](http://knockoutjs.com)\r\nto manage the user interface as done for web applications.\r\n\r\nHUD-type interfaces are going to be supported through WebKit or \r\nQGraphicsWidgets layered on top of a QGraphicsView; a proof\r\nof concept was implemented as a plugin, checkout the _gui.js_\r\nand _gui.html_ files [here](/candycode/loco/tree/master/modules/plugins/osgview/test). \r\n\r\n\r\n### WebKit integration\r\n\r\nWebKit is exposed to _LoCO_ through a WebWindow object.\r\n\r\nWebKit events are forwarded to the JavaScript context that creates\r\nthe WebKit window and can therefore be handled outside the WebKit\r\nJavaScript context.\r\n\r\nIt is possible to _inject_ JavaScript code and add QObject-derived types\r\nat page loading time.\r\n\r\nThe page _DOM_ tree is available and can be manipulated from outside\r\nthe page.\r\n\r\nA custom plugin factory is available to add _LoCO_ QWidgets directly into\r\na web page. [Example here](/candycode/loco/tree/master/modules/webplugins/osg-viewer).\r\n\r\n\r\n_Note_: I plan to keep supporting the WebKit1 interface, not WebKit2\r\nsince it requires one additional process for each web page which is \r\n__not__ something I want to have in a Desktop application. The current\r\nversion of QtWebKit based on WebKit 2.2 works well and will be supported\r\nfor quite some time anyway with commitments to fix all the high priority bugs.\r\n\r\n**Sample code**:\r\n\r\nLoad a webpage and change the _DOM_ tree on the fly setting the background to yellow\r\nand rotating all the ```<div>``` elements.\r\n\r\n```javascript\r\ntry {\r\n\r\n  var print = Loco.console.println;\r\n  var ctx = Loco.ctx;\r\n\r\n// command line\r\n  var cmdParam = ctx.cmdLine()[ctx.cmdLine().length - 1];\r\n  var WEBSITE = cmdParam.lastIndexOf( \".js\" ) < 0 ?\r\n                cmdParam : \"http://www.nyt.com\";\r\n\r\n// create main window\r\n  var ww = Loco.gui.create( \"WebWindow\" );\r\n// setup main window\r\n  ww.setAttributes( {DeveloperExtrasEnabled: true,\r\n                     LocalContentCanAccessFileUrls: true,\r\n                     LocalContentCanAccessRemoteUrls: true,\r\n                     AcceleratedCompositingEnabled: true } );\r\n  ww.setEnableContextMenu( true );\r\n  ww.setForwardKeyEvents( true );\r\n  if( !ww.syncLoad( WEBSITE, 5000 ) ) throw \"Load failure\";\r\n  var elements = ww.findElements( \"div\" );\r\n  print( elements.length );\r\n  print( elements[ 0 ].attributeNames() );\r\n  print( elements[ 0 ].eval( \"this.id\" ));\r\n  elements = ww.forEachElement( \"*\", \"this.childNodes.length === 0\" );\r\n  print( elements.length );\r\n  elements = ww.forEachElement( \"div\", \"this.style.backgroundColor='yellow'; false;\" );\r\n  print( elements.length );\r\n  elements = ww.forEachElement( \"div\", \"this.style['-webkit-transform']='rotate(1deg)'; false;\" );\r\n  print( elements.length );\r\n  ww.show();\r\n} catch(e) {\r\n  Loco.console.printerrln(e);\r\n  Loco.ctx.exit( -1 );\r\n}\r\n```\r\n\r\n### Filters\r\n\r\nThe code/bytes passed to the _LoCO_ intepreter are transformed trough\r\na chain of filters before the actual code is delivered to the interpreter.\r\nThis allows to e.g. load a source file and use Skulpt or CoffeeScript\r\nto generate JavaScript code on the fly and further pass the generated\r\ncode to lint.\r\n\r\n**Sample code**: \r\n\r\n1. load coffeescript \r\n2. create a filter named _coffeescript_ which invokes the function *loco_coffeeCompile* defined in the last function parameter; such function takes care of the actual CoffeeScript -> JavaScript translation\r\n3. evaluate code from file telling _LoCO_ that it has to be filtered with the _coffeescript_ filter   \r\n\r\n```javascript\r\ntry {\r\n  Loco.console.println(\"Interpreter: \" + Loco.ctx.jsInterpreterName() );\r\n  var WKIT = Loco.ctx.jsInterpreterName().indexOf( \"webkit\" ) >= 0;\r\n  Loco.ctx.include( \"../../filters/coffee-script-1.2.js\" );\r\n  if( !WKIT ) {\r\n    alert = Loco.console.println;\r\n  }\r\n  var c = CoffeeScript.compile( \"x = 32\", {bare: true} );\r\n  Loco.console.println( \"COFFEE: x = 32\\nJAVASCRIPT:\\n\" + c );\r\n  Loco.ctx.addScriptFilter( \"coffeescript\", \"loco_coffeeCompile_\",\r\n                            \"function loco_coffeeCompile_( coffeeCode ) {\" +\r\n                            \" return CoffeeScript.compile( coffeeCode, {bare: true} );\" +\r\n                            \"}\" );\r\n  Loco.ctx.evalFile( \"./test5.coffee\", [\"coffeescript\"] );\r\n  Loco.ctx.exit( 0 );\r\n} catch( e ) {\r\n  Loco.console.printerrln( e );\r\n  Loco.ctx.exit( -1 );\r\n}\r\n```\r\n\r\n### Synchronous calls\r\n\r\nWhere applicable I replaced async calls with callbacks with sync calls with\r\nsoft real-time guarantees i.e. invoke a synchronous function telling it how\r\nlong you are willing to wait for completion.\r\n\r\nE.g.\r\n\r\n```javascript\r\nwebWindow.syncLoad( \"http://www.github.com\", 5000 /*ms*/ );\r\n```\r\n\r\n### QtScript and JavaScriptCore(or V8) support\r\n\r\nJavaScript code can be run through either Qt's own script\r\nengine or the JavaScript engine embedded in WebKit.\r\nIn both cases the code is JIT compiled before execution.\r\n\r\nIn case QtScript is used it is possible to remove dependencies on QtWebKit\r\nand/or QtGUI.\r\n\r\nJavaScript code can be evaluated from within JavaScript through\r\nthe ```eval``` function or(if exposed) ```Context.eval```, in the\r\nformer case the code is interpreted, in the latter it goes through JIT\r\ncompilation.\r\n\r\n\r\n### Nested contexts\r\n\r\nIt is possible to create other JavaScript contexts from within\r\nany existing JavaScript context and marshal data between parent\r\nand child context. This allow the creation of sandboxed contexts\r\nwith only a subset of the JavaScript environment exposed to scripts.\r\n\r\n**Sample code**:\r\n\r\n1. create new context and install event handlers for errors or\r\n   javascript console messages\r\n2. enable access to source code passed to the context itself\r\n   for evaluation\r\n3. add objects to the context, including a reference to the context itself \r\n4. evaluate the code in the new context\r\n\r\n```javascript\r\n//check type of current context(WebKit or QtScript)\r\nvar WEBKIT = \r\n  Loco.ctx.jsInterpreterName().indexOf( \"webkit\" ) >= 0, \r\n  CONTEXT_TYPE = WEBKIT ? \"JavaScriptCoreContext\" : \"QtScriptContext\";\r\nvar newCtx = Loco.ctx.create( CONTEXT_TYPE );\r\nnewCtx.onError.connect( err );\r\nnewCtx.javaScriptConsoleMessage.connect(\r\n function( msg, line, src ) {\r\n   print( msg + \" at line \" + line );\r\n } );\r\nprint( \"Enable storage of source code passed for evaluation\" );\r\nnewCtx.storeCode = true;\r\nnewCtx.addObject( newCtx, \"ctx\" );\r\nprint( \"Added new context reference as 'ctx' into new context itself\" );\r\nnewCtx.addObject( Loco.console, \"io\" );\r\nprint( \"Added 'Loco.console' as 'io' into new context\" );\r\nvar CODE = \"io.println(ctx.code)\";\r\nprint( \"Evaluating code '\" + CODE + \"' in new context\" );\r\nnewCtx.eval( CODE ); //prints out code passed to newCtx itself!\r\n```\r\n\r\n### Custom resource access manager\r\n\r\nNetwork and filesystem access is controlled by resource access managers\r\nwhich can be configured through a regex engine or entirely replaced to:\r\n\r\n* specify read/write access permissions for files and directories\r\n* restrict access to specific network resources\r\n* filter and log network requests\r\n\r\n**Sample code 1**: enable file and network access from driver(C++) application\r\n\r\n```c++\r\n...\r\nloco::App app( qtApp, argc, argv );\r\n#ifdef ACCESS_TO_FILESYSTEM_ENABLED\r\napp.AddModuleToJS( new loco::FileSystem );\r\napp.SetAllowFileAccess( true );\r\napp.SetFilterFileAccess( false );\r\n#endif\r\n#ifdef ACCESS_TO_NETWORK_ENABLED\r\napp.SetAllowNetAccess( true );\r\napp.SetFilterNetRequests( false );\r\napp.AddModuleToJS( new loco::Network );\r\n#endif\r\n\r\n```\r\n\r\n**Sample code 2**: forbid read-write access to files with extension \"_config_\"\r\n\r\n```cpp\r\n...\r\napp.SetAllowFileAccess( true );\r\napp.SetFilterFileAccess( true );\r\napp.SetDenyFileRule( QRegExp( \".*\\\\.config$\" ), QIODevice::ReadWrite );\r\n```\r\n\r\nNote that access control is not entirely exposed to JavaScript, to allow\r\nfor the creation of binaries that have built-in, user-configurable access\r\ncontrol at the interpreter level.\r\n\r\nThis is something I borrowed from the mobile environment, Desktop applications\r\nare unfortunately still being developed with patterns from the 80s/90s with\r\nno concept of security or access control, any desktop application can easily\r\naccess the file system to read and broadcast data over the internet with little control\r\nover it, not to mention direct access to audio/video devices with no access protection\r\nat all(this is something I'll be addessing in future releases).\r\n\r\n\r\n### Custom protocols\r\n\r\nCustom protocol handlers can be installed in the web engine to allow\r\nfor addition of new schemes or filtering of requests for standard schemes.\r\n\r\n**Sample code**: create and install protocol handler\r\n\r\n```javascript\r\nvar customReqHandler = ctx.create( \"ProtocolHandler\" );\r\nctx.setEnableCustomProtocolHandlers( true );\r\nctx.addProtocolHandler( \"myprotocol\", customReqHandler );\r\nfunction handleCustomRequest( req, reply ) {\r\n  //generate some text content\r\n  var content = ...\r\n  reply.setHeader( \"ContentType\", \"text/html; charset ASCII\" );\r\n  reply.setHeader( \"ContentLength\", content.length );\r\n  reply.setContent( content );\r\n  reply.setUrl( \"file://\" );\r\n} \r\ncustomReqHandler.handleRequest.connect( handleCustomRequest );\r\n```\r\n\r\nNote that the custom protocol handler is added into the context **not**\r\nthe WebWindow: a scheme -> network-request-handler map is stored\r\ninto the context itself, which allows to match schemes/protocols in\r\nevery WebWindow with the proper handler.\r\n\r\nOverriding the standard _\"http(s)\"_ scheme it is possible to create\r\nproxys or embedded web applications with all the code written in\r\nJavaScript.    \r\n\r\nExample:\r\n\r\n[Application](/candycode/loco/blob/master/apps/locoplay-scripts/test20-custom-protocol.js)\r\n\r\n[Page](/candycode/loco/blob/master/apps/locoplay-scripts/test20-custom-protocol.html)\r\n \r\n\r\n### Multithreading\r\n\r\nScripts can be run in multiple contexts mapped to different threads.\r\n\r\nTwo thread objects currently available:\r\n\r\n* _Thread_: executes the code once and exits \r\n* _Thread loop_: \r\n  * thread is created and put in a wait state\r\n  * at each request for execution the code is executed and\r\n    the thread goes then back into the wait state \r\n\r\nInput data are passed to threads through their parent context.\r\n\r\nResults can be retrieved from the parent context/thread by:\r\n\r\n* explicitly joining/sychronizing then reading whatever data shared with the thread\r\n* reading from the _thread.data_ variable which implements future-like behavior and waits\r\n  until data become available\r\n\r\n[A working example example](/candycode/loco/blob/master/apps/locoplay-scripts/test23-thread-loop.js)\r\nis available.\r\n\r\n### Network\r\n\r\nSupport for tcp/udp sockets, http and ssl is included.\r\n\r\nSample code 1: http request\r\n\r\n```javascript\r\nvar http = Loco.net.create( \"Http\" );\r\nvar reply = http.get( \"http://www.marinij.com\", 10000 );\r\nvar headers = \"\";\r\nfor( var h in reply.headers ) {\r\n  headers += h + \": \";\r\n  if( reply.headers[ h ] ) headers += reply.headers[ h ];\r\n  headers += \"\\n\";\r\n}\r\nif( headers.length > 0 ) fwrite( \"test24-output-headers.txt\", headers );\r\nfwrite( \"test24-output.html\", reply.content );\r\nif( Loco.gui ) {\r\n  var ww = Loco.gui.create( \"WebWindow\" );\r\n  ww.load( \"test24-output.html\" );\r\n  ww.show();\r\n}\r\n```\r\n\r\nSample code 2: ssl socket\r\n\r\n```javascript\r\nvar socket = Loco.net.create( \"tcp-ssl-socket\" );\r\nsocket.connectTo( \"bugs.kde.org\", 443, 5000 );\r\n//if ( !socket.waitForEncrypted( 50000 ) ) throw socket.errorMsg();\r\nsocket.write( \"GET / HTTP/1.1\\r\\n\"+\r\n              \"Host: bugs.kde.org\\r\\n\"+\r\n              \"Connection: Close\\r\\n\\r\\n\" );\r\nvar data = \"\";\r\nwhile( socket.waitForReadyRead( 5000 ) ) data += socket.readAll();\r\nvar suffixLength = 5;\r\nprint( data.slice(0,data.length-suffixLength) ); //remove non printable chars\r\nprint( \"done\" );\r\n```\r\n\r\nA full SSL example is available as well:\r\n [encrypted fortune](/candycode/loco/blob/master/apps/locoplay-scripts/test28-ssl.js)\r\n\r\nIt is also possible to use the WebWindow object as a headless web browser to\r\nisssue http(s) requests, handle responses and save page snapshots to image or PDF\r\nfiles from command line applications.\r\n\r\n","tagline":"JavaScript/C++ application framework","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}